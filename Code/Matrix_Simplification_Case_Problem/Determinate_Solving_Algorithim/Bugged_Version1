#include <mpi.h>
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <time.h>

// determinate solving function
// the origional determinate code was not my origional work
// the MPI implementation is my addition to this program
double determinate(int m, int* p, int size, int rank) {

	long double ans = 0, inner_sol, inner_det;
	int a, b, c, d, start_val, end_val, upperLimit = m;
	start_val = ceil(rank * (upperLimit / size));

	// define the ranged ranking algoritim
	if (rank == (size - 1)) {
		// upperLimit + 1 'fixes' the solution issue.
		end_val = upperLimit + 1;
	}
	else {
		end_val = start_val + ceil(upperLimit / size) - 1;
	}

	// printf("%d range is %d to %d on the matrix \n \n",rank, start_val,end_val );

	/////////////////1 x 1 matrix condition////////////////////////////////////////
	
	if ((upperLimit == 1) || (upperLimit == 2)) {
		if (upperLimit == 1) {
			ans = *p;
		}
		else {
			a = *p;
			b = *(p + 1);
			c = *(p + 2);
			d = *(p + 3);
			ans = (a * d) - (b * c);
		}
	}
	
	/////////////////n x n matrix condition////////////////////////////////////////
	else
	{
		int i, j, k, l, n, sign, basic, element;
		n = 0;
		sign = 1;
		int * q;

		// printf("The matrix size is: %d", m);
		q = (int*)calloc(((upperLimit - 1) * (upperLimit - 1)), sizeof(int));

		for (i = start_val; i != end_val; i++)
		{
			l = 0;
			n = 0;
			basic = * (p + i);

			for (j = start_val; j != end_val; j++)
			{
				for (k = start_val; k != end_val; k++)
				{
					element = *(p + l);
					if ((j == 0) || (i == k));
					else
					{
						*(q + n) = element;
						n = n + 1;
					}
					l = l + 1;
				}
			}
			inner_det = determinate(upperLimit - 1, q, size, rank);
			inner_sol = sign * basic * inner_det;

			ans = ans + inner_sol;
			sign = sign * (- 1);
		}
	}
	printf("I am ans and I have the final value: %f I am rank: %d \n \n", ans, rank);
	return ans;
}


// main function to complete the operation
int main(int argc, char* argv[]) {

	MPI_Init(&argc, &argv);
	int size, rank;
	MPI_Comm_rank(MPI_COMM_WORLD, &rank);
	MPI_Comm_size(MPI_COMM_WORLD, &size);

	//////////////////// define numbers in the matrix ///////////////////////////////
	// note that all numbers be able
	// to form a square matrix of n x n dimentions.
	// only perfect square entires are allowed


	int* p, r = 4, c = 4;				
	int numberOfNumbers = r * c;
	//srand(time(0));

	// To get started, define r rows.
	p = (int*)calloc(r * r, sizeof(int));

	double* numberArray = (double*)calloc(numberOfNumbers, sizeof(double));

	for (int h = 0; h < numberOfNumbers; h++) 
	{
		numberArray[h] = rand() % 100;
		if (rank == 0) {
			printf("\n %f \n", numberArray[h]);
		}
	}

	int i, j, k, u = 0;
	// Define the numbers in your array:
	for (i = 0; i < r; i++) 
	{
		for (j = 0; j < c; j++) 
		{
			k = numberArray[u];
			*(p + i*c + j) = k;
			u++;
		}
	}
	double reducedSoln = 0;
	double ans = determinate(r, p, size, rank);
	
	MPI_Reduce(&ans, &reducedSoln, 1,MPI_LONG_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);



	if (rank == 0) {
		printf("Solution is: %lf", reducedSoln);
	}

	MPI_Finalize();
	return 0;
}
